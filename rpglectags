#!/usr/bin/env perl
=pod

=head1 NAME

rpglectags - Creating ctags compatible files from RPG/ILE files

=head1 SYNOPSIS

B<rpglectags>
[B<-f output | -o output>]
[B<-a>]
[B<--help>]
[B<--version>]
[F<files>]...

=begin :text

=head1 INSTALL

First clone this repository, and then run:

    sudo make install

This will install two files: C</usr/bin/rpglectags> and
C</usr/share/man/man1/rpglectags.1>.

One can uninstall by running:

    sudo make clean

=end :text

=head1 DESCRIPTION

B<rpglectags> will create a ctags compatible file called `tags'.

The B<rpglectags> program generate an index (or `tag') file for RPG/ILE objects
found in file(s). This tag file allows these items to be quickly and easily
located by a text editor or other utility. A `tag' signifies a language object
for which an index entry is available.

Tag index files are supported by a numerous editors, which allows the user to
locate the objects associated with a name appearing in a source file and jump to
the file and line which defines the name. Among other are:

    Vi(1), Vim(1), Sublime Text, Visual Studio Code, Notepad++, ...

At the moment there is support for:

=over 4

=item B<Procedures>

Free format is supported though C<dcl-proc>.

Fixed format is supported though C<pxxxxxxxxxxxxxxxxxb>. Continues procedure
names is also supported, i.e. C<pxxxxxx...\np_________________b>. Where C<\n> is
a literal newline and C<_> is a literal space. Up to 7 leading spaces will be
supported.

=item B<Subroutines>

Free format is supported though C<begsr>.

Fixed format is supported though C<cxxxxxxxxxxxxxxxxxxxbegsr>. Continues
declarations is not supported. Up to 7 leading spaces will be supported.


=item B<Procedure interface>

Free format is supported though C<dcl-pi>.

Fixed format is supported though C<dxxxxxxxxxxxxxxxxxpi>. Continues procedure
interfaces is also supported, i.e. C<dxxxxxx...\nd_________________pi>. Where
C<\n> is a literal newline and C<_> is a literal space. Up to 7 leading spaces
will be supported.

=item B<Data structures>

Free format is supported though C<dcl-ds>.

Fixed format is supported though C<dxxxxxxxxxxxxxxxxxds>. Continues declarations
is not supported. Up to 7 leading spaces will be supported.

=item B<Stand alone and constant declarations>

Free format is supported though C<dcl-s> and C<dcl-c>.

Fixed format is supported though C<dxxxxxxxxxxxxxxxxxs> and
C<dxxxxxxxxxxxxxxxxxc>. Continues declarations is not supported. Up to 7
leading spaces will be supported.

=back

=head1 OPTIONS

=over 4

=item B<-f> I<file> | B<-o> I<file>

Write tags til specified file. Value of `-' writes tags to stdout.
Default is `tags'

=item B<-a>

Append the tags to an existing tag file

=item B<-h>, B<--help>

Print a summary of options and exit.

=item B<--version>

Print version information on standard output then exit successfully.

=back

=head1 EXAMPLES

To create tags from the file `test.rpgle', you'd use

    rpglectags test.rpgle

To create tags from all rpgle and sqlrpgle files recursively, you might say

    find . -type f \( -name '*.rpgle' -o -name '*.sqlrpgle' \) \
      -exec rpglectags {} +

More examples:

    rpglectags -f - test2.rpgle        # Print tags to stdout
    rpglectags -a test2.rpgle          # Append tags to the 'tags' file

=head1 TAG FILE FORMAT

Each entry in the tag file consists of a separate line, each looking like this
in the most general case:

    {tagname}<TAB>{tagfile}<TAB>{tagaddress};"<TAB>{tagfields}

The fields and separators of these lines are specified as follows:

=over 4

=item B<1.>

Tag name

=item B<2.>

Single tab character

=item B<3.>

Name of the file in which the object associated with the tag is located

=item B<4.>

Single tab character

=item B<5.>

Tag address. A non B<magic> pattern enclosed in B</> or B<?> or a line number.

=item B<6.>

A constant `;"' for backward compatibility with vi(1)

=item B<7.>

Extra fields narrowing down the type of tag entry, i.e. kind:{fvms},
struct:nameOfStruct

=back

=head1 EXIT STATUS

The following exit values shall be returned:

=over 4

=item B<0>

Successful completion.

=item B<1>

Error parsing command-line argument.

=back

=head1 SEE ALSO

ctags(1)

=head1 AUTHOR

Andreas Louv <andreas@louv.dk>.

=head1 LICENSE

This program is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.

=cut

use strict;
use warnings;
use v5.16;
use Getopt::Long;
use Carp;

our $APP     = 'rpglectags';
our $VERSION = '1.5.0';

my $currentProc        = undef;
my $currentProcAddress = undef;

my $output_file   = 'tags';
my $append_output = 0;

GetOptions(
  "f|o=s" => \$output_file,
  "a" => \$append_output,
  "help" => sub {
    printf "%s [-f output | -o output] [-a] [--help] [--version] [files]...\n", $APP;
    exit;
  },
  "version" => sub { printf "%s v%s\n", $APP, $VERSION; exit }
) or exit 1;

main();

sub main
{
  my @tags        = get_tags();
  my @tabbed_tags = ();

  if ($append_output) {
    if (open(my $fh, '<', $output_file)) {
      while (my $line = <$fh>) {
        chomp($line);
        push(@tabbed_tags, $line) unless $line =~ /^!/;
      }
      close($fh);
    }
  }

  push(@tabbed_tags,
    join("\t", '!_TAG_FILE_FORMAT', '2', '//'),
    join("\t", '!_TAG_FILE_SORTED', '2', '//'),
    join("\t", '!_TAG_PROGRAM_AUTHOR', 'Andreas Louv', '/andreas@louv.dk/'),
    join("\t", '!_TAG_PROGRAM_NAME', 'rpglectags', '//'),
    join("\t", '!_TAG_PROGRAM_URL', 'https://github.com/andlrc/rpglectags', '/Official Website/'),
    join("\t", '!_TAG_PROGRAM_VERSION', $VERSION, '//')
  );

  foreach my $tag (@tags) {
    my @converted_tag = convert_tag($tag);
    if (@converted_tag) {
      push(@tabbed_tags, @converted_tag);
    }
  }

  @tabbed_tags = sort({ fc($a) cmp fc($b) } @tabbed_tags);

  if ($output_file ne '-') {
    open(my $tags_fh, '>', $output_file)
      or croak("Failed to open tags: $!");
    print $tags_fh $_ . "\n" for @tabbed_tags;
    close($tags_fh);
  }
  else {
    print $_ . "\n" for @tabbed_tags;
  }

  return;
}
# Returns an array of tag hashes that contains:
# tagname, tagfile, tagaddress and tagfields
sub get_tags
{
  my @tags = ();

  while (my $line = <>) {
    $line =~ y/\r//d;

    if ($. == 1 || $line =~ /end-proc/xi || $line =~ /^\s{0,7}p[\w\s]{17}e\b/xi) {
      $currentProc        = undef;
      $currentProcAddress = undef;
      next;
    }

    # Free 7.1 Procedure
    if ($line =~ /(^\s*dcl-proc\s+(\w+).)/xi) {
      my $name    = $2;
      my $address = create_address($1);

      my $tag = {
        "tagname"    => $name,
        "tagfile"    => $ARGV,
        "tagaddress" => $address,
        "tagfields"  => {
          "kind" => "f"
        }
      };

      push(@tags, $tag);

      $currentProc        = $name;
      $currentProcAddress = $address;

      next;
    }

    # Fixed Procedure
    if ($line =~ /^\s{0,7}p(?=[\w\s]{17}b|\s*\w+\.\.\.)\s*\w+/xi) {
      my $address = create_address($line =~ s/(?<=\bb\b).*//xir);

      # RPG/ILE fixed can be multiply lines if the line is ending in ...
      if ($line =~ s/\.\.\.\s*$//xi) {
        $line .= <> =~ s/\s{0,7}p\b//xir;
        $line =~ y/\r//d;
      }

      my ($procName) = $line =~ /\s{0,7}p\s+(\w+)/xi;

      my $tag = {
        "tagname"    => $procName,
        "tagfile"    => $ARGV,
        "tagaddress" => $address,
        "tagfields"  => {
          "kind" => "f"
        }
      };

      push(@tags, $tag);

      $currentProc        = $procName;
      $currentProcAddress = $address;

      next;
    }

    # Free 7.1 Pi
    if ($line =~ /(^\s*dcl-pi\b.)/xi) {
      my $address = create_address($1, 1);

      # Slurp all lines from dcl-ds ... end-ds
      while ($line !~ /\bend-pi\b/xi) {
        # We should never iterate over another file. This also prevents infinite
        # iteration with misformed data
        last if eof;
        $line .= <>;
        $line =~ y/\r//d;
      }

      push(@tags, parse_free_dspi($address, $line, 'pi', {
        "kind" => "v"
      }));

      next;
    }

    # Fixed Pi
    if ($line =~ /^\s{0,7}d(?=[\w\s]{17}pi|\s*\w+\.\.\.)\s*\w+/xi) {

      # RPG/ILE fixed can be multiply lines if the line is ending in ...
      if ($line =~ s/\.\.\.\s*$//xi) {
        $line .= <> =~ s/(?<=\bpi\b).*//xir;
        $line =~ y/\r//d;
      }

      my $address = create_address($line =~ s/(\bpi\b).*//xir, 1);

      # Slurp all lines from d xxxxxx ... d xxxxxx
      $line .= slurp_fixed_dspi();

      push(@tags, parse_fixed_dspi($address, $line, 'pi', {
        "kind" => "v"
      }));

      next;
    }

    # Free subroutine declaraion (glorified goto)
    if ($line =~ /(^\s*\bbegsr\s+(\w+).)/xi) {
      my $name    = $2;
      my $address = create_address($1, 1);

      my $tagfields = {
        "kind" => "f"
      };

      my $tag = {
        "tagname"    => $name,
        "tagfile"    => $ARGV,
        "tagaddress" => $address,
        "tagfields"  => $tagfields
      };

      push(@tags, $tag);

      next;
    }

    # Fixed subroutine declaraion (glorified goto)
    if ($line =~ /^\s{0,7}c[\w\s]{19}\bbegsr\b/) {

      my ($name)  = $line =~ /\s{0,7}c\s*(\w+)/xi;
      my $address = create_address($line =~ s/(?<=\bbegsr\b).*//xir, 1);

      my $tagfields = {
        "kind" => "f"
      };

      my $tag = {
        "tagname"    => $name,
        "tagfile"    => $ARGV,
        "tagaddress" => $address,
        "tagfields"  => $tagfields
      };

      push(@tags, $tag);

      next;
    }

    # Free 7.1 DS
    if ($line =~ /(^\s*\bdcl-ds\s+(\w+).)/xi) {
      my $name    = $2;
      my $address = create_address($1, 1);

      my $tagfields = {
        "kind" => "s"
      };

      my $tag = {
        "tagname"    => $name,
        "tagfile"    => $ARGV,
        "tagaddress" => $address,
        "tagfields"  => $tagfields
      };

      push(@tags, $tag);

      # Don't try to find members if this DS is based on another DS
      next if ($line =~ /\b(likeds)\b/xi);

      # Slurp all lines from dcl-ds ... end-ds
      while ($line !~ /\bend-ds\b/xi) {
        # We should never iterate over another file. This also prevents infinite
        # iteration with misformed data
        last if eof;
        $line .= <>;
        $line =~ y/\r//d;
      }

      # Don't try to find members if this DS is based on an external database
      # structure
      next if ($line =~ /\b(extname)\b/xi);

      push(@tags, parse_free_dspi($address, $line, 'ds', {
        "kind"   => "m",
        "struct" => $name
      }));

      next;
    }

    # Fixed DS
    if ($line =~ /^\s{0,7}d[\w\s]{17}\bds\b/xi) {

      my ($name)  = $line =~ /^\s{0,7}d\s*(\w+)/xi;
      my $address = create_address($line =~ s/(?<=\bds).*//xir, 1);

      my $tagfields = {
        "kind" => "s"
      };

      my $tag = {
        "tagname"    => $name,
        "tagfile"    => $ARGV,
        "tagaddress" => $address,
        "tagfields"  => $tagfields
      };

      push(@tags, $tag);

      # Don't try to find members if this DS is based on another DS
      next if ($line =~ /\b(likeds)\b/xi);

      # Slurp all lines from d xxxxxx ... d xxxxxx
      $line .= slurp_fixed_dspi();

      # Don't try to find members if this DS is based on an external database
      # structure
      next if ($line =~ /\b(extname)\b/xi);

      push(@tags, parse_fixed_dspi($address, $line, 'ds', {
        "kind"   => "m",
        "struct" => "$name"
      }));

      next;
    }

    # Free 7.1 const and standalone
    if ($line =~ /(^\s*\bdcl-[sc]\s+(\w+).)/xi) {
      my $name    = $2;
      my $address = create_address($1, 1);

      my $tagfields = {
        "kind" => "v"
      };

      my $tag = {
        "tagname"    => $name,
        "tagfile"    => $ARGV,
        "tagaddress" => $address,
        "tagfields"  => $tagfields
      };

      push(@tags, $tag);

      next;
    }

    # Fixed const and standalone
    if ($line =~ /^\s{0,7}d[\w\s]{17}\b[sc]\b/xi) {
      my ($name)  = $line =~ /^\s{0,7}d\s*(\w+)/xi;
      my $address = create_address($line =~ s/(?<=\b[sc]\b).*//xir, 1);

      my $tagfields = {
        "kind" => "v"
      };

      my $tag = {
        "tagname"    => $name,
        "tagfile"    => $ARGV,
        "tagaddress" => $address,
        "tagfields"  => $tagfields
      };

      push(@tags, $tag);

      next;
    }
  } continue {
    # Make sure $. starts from 1 for each file:
    close ARGV if eof;
  }

  return @tags;
}
# Contains a tag hash to a <TAB> separated line
sub convert_tag
{
  my ($tag)      = @_;
  my $tagname    = $tag->{tagname};
  my $tagfile    = $tag->{tagfile};
  my $tagaddress = $tag->{tagaddress};
  my $tagfields  = $tag->{tagfields};

  # Sometimes we add wrong tags, some of these doesn't contain all needed
  # information.
  return unless $tagname && $tagfile && $tagaddress;

  my @tag = (
    $tagname,
    $tagfile,
    $tagaddress . ';"'
  );

  for my $key (sort keys %{ $tagfields }) {
    push(@tag, $key . ':' . $tagfields->{$key});
  }

  push(@tag, "file:");

  return join("\t", @tag);
}
# Reads multiply lines from the input file. Stops when a line not matching
# (Simplified):
# d hello\s*$
# \s*d hello\s*$
sub slurp_fixed_dspi
{
  my $line = '';
  while (1) {
    # We should never iterate over another file. This also prevents infinite
    # iteration with misformed data
    last if eof;
    my $pos       = tell(ARGV);
    my $next_line = <>;

    # Empty lines doesn't mean the ds/pi stops, but doesn't contain any useful
    # information either, just skip them.
    next if $next_line =~ /^\s*$/;

    if ($next_line !~ /^\s{0,7}d(?=[\w\s]{17}\W)\s*\w+/xi) {
      seek(ARGV, $pos, 0);
      last;
    }

    $line .= $next_line;
  }

  $line =~ y/\r//d;

  return $line;
}
# Create tag entries in the @tags array from slurped lines.
sub parse_free_dspi
{
  my ($parentAddress, $line, $type, $tagfields) = @_;

  my @tags = ();

  foreach (split("\n", $line)) {
    next if /\bdcl-$type\b|\bend-$type\b/xi;

    if (/(^\s*(\w+).)/) {
      my $name    = $2;
      my $address = create_address($1);

      my $tag = {
        "tagname"    => $name,
        "tagfile"    => $ARGV,
        "tagaddress" => "$parentAddress;$address",
        "tagfields"  => $tagfields
      };

      push(@tags, $tag);
    }
  }

  return @tags;
}
# Create tag entries in the @tags array from slurped lines from slurp_fixed_dspi
sub parse_fixed_dspi
{
  my ($parentAddress, $line, $type, $tagfields) = @_;

  my @tags = ();

  foreach (split("\n", $line)) {
    # Remove the first line, as well as lines that doesn't have a name[1]
    # [1] It's possible to align a DS meaning no name is given:
    # d myDs            ds
    # d field1                       256    varying
    # d                                4    varying
    # d field2                       256    varying
    next if /^\s{0,7}d(\s{17}|[\w\s]{17}$type)/xi;

    if (/(\s{0,7}d\s*(\w+).)/xi) {
      my $name    = $2;
      my $address = create_address($1);

      my $tag = {
        "tagname"    => $name,
        "tagfile"    => $ARGV,
        "tagaddress" => "$parentAddress;$address",
        "tagfields"  => $tagfields
      };

      push(@tags, $tag);
    }
  }

  return @tags;
}
# Create a tag address, everything but '^', '$' and '/' is literal, so
# only those three characters needs to be escaped.
# All addresses should be wrapped in /^.../
sub create_address
{
  my ($address, $addProc) = @_;

  $address =~ y/\n//d;
  $address =~ s/[\^\/\$]/\\$&/g; # Escape '^', '$' and '/'
  $address = "/^$address/";

  $address = "$currentProcAddress;$address" if $addProc && $currentProcAddress;

  return $address;
}
